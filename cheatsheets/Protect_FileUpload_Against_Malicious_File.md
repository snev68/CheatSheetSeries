# File Upload Cheat Sheet

## Introduction

File upload is becoming more and more an essential part of any application, where the user is able to upload their photo, their CV, or a video showcasing a project they are working on. It is evident that applications should be able to handle file uploads based on the business requirement. In return, the application should be able to fend off bogus, and malicious files in a way to keep the application and the users safe.

In short, the following principles should be followed to reach a secure file upload implementation:

- **Whitelist allowed extensions. Only allow safe and critical extensions for business functionality**
  - **Ensure that [input validation](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Input_Validation_Cheat_Sheet.md#validating-free-form-unicode-text) is applied before validating the extensions.**
- **Allowed users only can upload files**
- **Validate the file type, don't trust the [Content-Type header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type)  as it can be spoofed**
- **Change the file name to something generated by the application**
- **Set a file name length limit. Restrict the allowed characters if possible**
  - **Setting a character limit could deny the attacker from sending null bytes, adding secondary extensions, and performing XSS attacks if the file name is reflected**
- **Set a file size limit**
- **Store the files on a different server. If that's not possible, store them in a private directory**
  - **In the case of public access to the files, ensure that proper permissions are set, file names are safe, and encoded**
- **Run the file through an antivirus or a sandbox if available to validate that it doesn't contain malicious or bogus data**
- **Ensure the usage of secure and updated libraries for your needs**
- **Add CSRF protection, as this is input being served from the user**

## Contents

- [File Upload Threats](#file-upload-threats)
    - [Malware Upload](#malware-upload)
    - [Public File Retrieval](#public-file-retrieval)
- [File Upload Protection](#file-upload-protection)
    - [Extension Validation](#extension-validation)
        - [Whitelist Extensions](#whitelist-extensions)
        - [Blacklist Extensions](#blacklist-extensions)
    - [User Permissions](#user-permissions)
    - [Content-Type Validation](#content-type-validation)
    - [File Name Sanitization](#file-name-sanitization)
    - [File Storage Location](#file-storage-location)
    - [System Permissions](#system-permissions)
    - [Upload and Download Limits](#upload-and-download-limits)
- [Java Code Snippets](#java-code-snippets)

## File Upload Threats

In order to assess and know exactly what controls to implement, knowing what you're facing is essential to protect your assets. The following sections will hopefully showcase the risks accompanying the file upload functionality.

### Malicious Files

The attacker delivers a file for malicious intent, such as:

1. Exploit vulnerabilities in the file parser or processing module (_e.g._ [ImageTrick Exploit](https://imagetragick.com/), [XXE](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing))
2. Use the file for phishing (_e.g._ careers form)
3. Send ZIP bombs, XML bombs (otherwise known as billion laughs attack), or simply huge files in a way to fill the server storage which hinders and damages the server's availability
4. Overwrite an existing file on the system
5. Client-side active content that could lead to all types of client-side attacks if the file is publicly retrievable
6. Make the user upload a file without the user's consent, by crafting a Cross-Site Request Forgery attack (CSRF).

### Public File Retrieval

If the file uploaded is publicly retrievable, additional threats can be addressed:

1. Public disclosure of other files
2. Initiate a DoS attack by requesting lots of files. Requests are small, yet responses are much larger
3. File content that could be deemed as illegal, offensive, or dangerous (_e.g._ personal data, copyrighted data, etc.) which will make you a host for such malicious files.

## File Upload Protection

### Extension Validation

Ensure that the validation occurs after decoding the file name, and that a proper filter is set in place in order to avoid certain known bypasses, such as the following:

- Double extensions, _e.g._ `.jpg.php`, where it circumvents easily the regex `\.jpg`
- Null bytes, _e.g._ `.php%00.jpg`, where `.jpg` gets truncated and `.php` becomes the new extension
- Generic bad regex that isn't properly tested and well reviewed. Refrain from building your own logic unless you have enough knowledge on this topic.

Refer to the [Input Validation CS](Input_Validation_Cheat_Sheet.md) to properly parse and process the extension.

#### Whitelist Extensions

Ensure the usage of *business-critical* extensions only, without allowing any type of *non-required* extensions. If the system requires:

- image upload, allow one type that is agreed upon to fit the business requirement;
- cv upload, allow `docx` and `pdf` extensions.

Based on the needs of the application, ensure the **least harmful** and the **lowest risk** file types to be used.

#### Blacklist Extensions

> Blacklisting extensions is a bad idea and is very dangerous. Don't do it unless you have no other choice!

In order to perform this validation, specifying and identifying which patterns that could should be rejected are used in order to protect the service.

### Content-Type Validation

Other than defining the extension of the uploaded file, its MIME-type can be checked for a quick protection against simple file upload attacks.

This can be done preferrably in a whitelist approach; otherwise, this can be done in a blacklist approach.

> This should not be used on its own, as bypassing it is pretty common and easy.

### File Name Sanitization

Multiple threats relate to the file-name, thus, it is essential to ensure that the file-name is stored in a secure fashion.

File-names can endager the system in multiple ways, either by using non acceptable characters, or by using special and restricted filenames, which can be found under the following [MSDN guide](https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file?redirectedfrom=MSDN#naming-conventions). For a wider overview on different filesystems and how they treat files, refer to [Wikipedia's Filename page](https://en.wikipedia.org/wiki/Filename).

In order to avoid the above mentioned threat, creating a **random string** as a file-name, _e.g_ generating a UUID/GUID, is essential. If the file-name is required by the business needs, proper input validation should be done for client-side (_e.g._ active content) and back-end side (_e.g._ special files overwrite or creation) attack vectors. File-name length limits should be taken into consideration based on the system storing the files, as each system has its own file name length limit.

### File Content Safety

As mentioned in the [Public File Retrieval](#public-file-retrieval) section, file content can contain unwelcomed data and information.

The File Upload service should allow users to report illegal content, and copyright owners to report abuse.

If there are enough resources, manual file review should be conducted in a sandboxed environment before releasing the files to the public.

Adding some automation to the review could be helpful, by conducting keyword analysis, which should be a harsh process and well studied before its usage. Some services (_e.g._ Virus Total) provide APIs to scan files against well known malicious file hashes.

### File Storage Location

The location where the files should be stored must be chosen based on security and business requirements. The following points are set by security priority, and are inclusive:

1. Store the files on a **different host**, which allow for complete segragation of duties between the application serving the user, and the host handling file uploads and their storage.
2. Store the files **outside the webroot**, where only administrative access is allowed.
3. Store the files **inside the webroot**, and set them in write permissions only.
   - If read access is required, setting proper controls is a must (_e.g._ internal IP, authorized user, etc.)
4. Store the files to a **database**, most preferrably as Blobs in a NoSQL database. The database should be chosen based on the application's requirements.

> Some files are emailed on point, or processed and dismissed, without being stored. It is essential to conduct the security measures discussed in this sheet before doing any actions on them.

### User Permissions

Before any file upload service is accessed, proper validation should occur on two levels for the user uploading a file:

- Authentication level
  - The user should be a registered user, or an identifiable user, in order to set restrictions and limitations for their upload capabilities
- Authorization level
  - Make sure that the user's accesses allow them to upload a file, or multiple files for administrative cases.

### System Permissions

Files should be stored in a way that ensures:

- Allowed system users are the only ones capable of reading the files
- Required modes only are set for the file
  - If execution is required, scanning the file before running it is required as a security best practice, to ensure that no macros or hidden scripts are available.

### Upload and Download Limits

The application should set proper size limits for the upload service in order to protect the file storage capacity. The file size limit should be considered after file decompression is conducted, and by using secure methods to calculate zip files size. For more on this, see how to [Safely extract files from ZipInputStream](https://wiki.sei.cmu.edu/confluence/display/java/IDS04-J.+Safely+extract+files+from+ZipInputStream), Java's input stream to handle ZIP files.

It should set proper request limits as well for the download service if available to protect the server from DoS attacks.

## Java Code Snippets

[Document Upload Protection](https://github.com/righettod/document-upload-protection) repository written by Dominique for certain document types in Java.