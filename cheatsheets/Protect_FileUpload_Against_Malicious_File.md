# File Upload Cheat Sheet

## Introduction

File upload is becoming more and more an essential part of any application, where the user is able to upload their photo, their CV, or a video showcasing a project they are working on. It is evident that applications should be able to handle file uploads based on the business requirement. In return, the application should be able to fend off bogus, and malicious files in a way to keep the application and the users safe.

In short, the following principles should be followed to reach a secure file upload implementation:

- **Whitelist allowed extensions. Only allow safe and critical extensions for business functionality**
  - **Ensure that [input validation](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Input_Validation_Cheat_Sheet.md#validating-free-form-unicode-text) is applied before validating the extensions.**
- **Allowed users only can upload files**
- **Validate the file type, don't trust the [Content-Type header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type)  as it can be spoofed**
- **Change the file name to something generated by the application**
- **Set a file name length limit. Restrict the allowed characters if possible**
  - **Setting a character limit could deny the attacker from sending null bytes, adding secondary extensions, and performing XSS attacks if the file name is reflected**
- **Set a file size limit**
- **Store the files on a different server. If that's not possible, store them in a private directory**
  - **In the case of public access to the files, ensure that proper permissions are set, file names are safe, and encoded**
- **Run the file through an antivirus or a sandbox if available to validate that it doesn't contain malicious or bogus data**
- **Ensure the usage of secure and updated libraries for your needs**

## Contents

- [File Upload Threats](#file-upload-threats)
    - [Malware Upload](#malware-upload)
    - [Public File Retrieval](#public-file-retrieval)
- [File Upload Protection](#file-upload-protection)
    - [Extension Validation](#extension-validation)
        - [Whitelist Extensions](#whitelist-extensions)
        - [Blacklist Extensions](#blacklist-extensions)
    - [User Permissions](#user-permissions)
    - [Content-Type Validation](#content-type-validation)
    - [File Name Sanitization](#file-name-sanitization)
    - [File Storage Location](#file-storage-location)
    - [System Permissions](#system-permissions)
    - [Upload and Download Limits](#upload-and-download-limits)
- [Java Code Snippets](#java-code-snippets)

## File Upload Threats

In order to assess and know exactly what controls to implement, knowing what you're facing is essential to protect your assets. The following sections will hopefully showcase the risks accompanying the file upload functionality.

### Malware Upload

The attacker delivers a file for malicious intent, such as:

1. Call the file to execute code (_e.g._ [ImageTrick Exploit](https://imagetragick.com/))
2. Use the file for phishing (_e.g._ careers form)
3. Send ZIP bombs, or simply huge files in a way to fill the server storage which hinders the server's availability
4. Overwrite an existing file on the system
5. Client-side active content that could lead to all types of client-side attacks if the file is publicly retrievable

### Public File Retrieval

If the file uploaded is publicly retrievable, additional threats can be addressed:

1. Public disclosure of other files
2. Initiate a DoS attack by requesting lots of files. Requests are small, yet responses are much larger

## File Upload Protection

### Extension Validation

Ensure that the validation occurs after decoding the file name, and that a proper filter is set in place (_e.g._ `\.png` vs `\.png\z`; etc.). Refer to the [Input Validation CS](Input_Validation_Cheat_Sheet.md) for more information.

#### Whitelist Extensions

Ensure the usage of *business-critical* extensions only, without allowing any type of *non-required* extensions. If the system requires:

- image upload, allow one type that is agreed upon to fit the business requirement;
- cv upload, allow `docx` and `pdf` extensions. Access files through a closed down machine.

Based on the needs of the application, ensure the **least harmful** and the **lowest risk** file types to be used.

#### Blacklist Extensions

> This should be only used when the [whitelist approach](#whitelist-extensions) fails, and is in no way a replacement for it.

In order to perform this validation, specifying and identifying which patterns that could should be rejected are used in order to protect the service.

```python
# This code snippet only serves as an example, and should not be used
blacklist = ["php", "php5"]  # can be replaced with a regex pattern, but that would be even weaker, such as \.php$
for bad in blacklist:
    if "file.php".endswith(bad):
        // raise exception
```

### User Permissions

Before any file upload service is accessed, proper validation should occur on two levels for the user uploading a file:

- Authentication level
  - The user should be a registered user, or an identifiable user, in order to set restrictions and limitations for their upload capabilities
- Authorization level
  - Make sure that the user's accesses allow them to upload a file, or multiple files for administrative cases.

### Content-Type Validation

Other than defining the extension of the uploaded file, its MIME-type can be checked for a quick protection against simple file upload attacks.

This can be done preferrably in a whitelist approach; otherwise, this can be done in a blacklist approach.

> This should not be used on its own, as bypassing it is pretty common and easy.

### File Name Sanitization

Multiple threats relate to the file-name, thus, it is essential to ensure that the file-name is stored in a secure fashion.

This can be done by creating a **random string** as a file-name. If the file-name is required by the business needs, proper input validation should be done for client-side (_e.g._ active content) and back-end side (_e.g._ special files overwrite or creation) attack vectors. File-name length limits should be taken into consideration based on the system storing the files, as each system has its own file name length limit.

### File Storage Location

All file uploaded will be stored in a location on the server. This location must be chosen based on security and business requirements. The following points are set by security priority, and are inclusive:

1. Store the files on a **different host**, which allow for complete segragation of duties between the application serving the user, and the host handling file uploads and their storage.
2. Store the files in a **private directory**, where only administrative access is allowed.
3. Store the files on a **public directory**, and set them in write permissions only.

> If read access is required, setting proper controls is a must (_e.g._ internal IP, authorized user, etc.)

### System Permissions

Files should be stored in a way that ensures:

- Allowed system users are the only ones capable of reading the files
- Required modes only are set for the file
  - If execution is required, scanning the file before running it is required as a security best practice, to ensure that no macros or hidden scripts are available.

### Upload and Download Limits

The application should set proper size limits for the upload service in order to protect the file storage capacity. The file size limit should be considered after file decompression is conducted, and by using secure methods to calculate zip files size.

It should set proper request limits as well for the download service if available to protect the server from DoS attacks.

## Java Code Snippets

[Document Upload Protection](https://github.com/righettod/document-upload-protection) repository written by Dominique for certain document types in Java.